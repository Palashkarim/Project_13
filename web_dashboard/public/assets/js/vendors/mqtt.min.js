/*!
 * mqtt.min.js — local loader + development stub
 * --------------------------------------------------------------------
 * PRODUCTION: Put the official open-source MQTT.js build at:
 *   /assets/js/vendors/mqtt.actual.min.js
 * This loader will try to load it. If missing, it exposes a DEV STUB so
 * your UI runs offline. The stub implements a subset of:
 *   mqtt.connect(url, options) -> client
 *   client.publish(topic, payload, opts)
 *   client.subscribe(topic, opts, cb?)
 *   client.unsubscribe(topic, cb?)
 *   client.end(force?)
 *   client.on('connect'|'reconnect'|'close'|'error'|'message', fn)
 *
 * NOTE: The stub does NOT speak MQTT to a broker. It’s a local event bus
 * for UI development when your broker/WebSocket isn’t available.
 * --------------------------------------------------------------------
 * License: MIT (this loader/stub). MQTT.js is (MIT) — ship separately.
 */
(function(){
  var REAL_PATH = '/assets/js/vendors/mqtt.actual.min.js';

  function loadReal(src, done, fail){
    try{
      var s = document.createElement('script');
      s.src = src; s.async = true;
      s.onload = function(){ done && done(); };
      s.onerror = function(){ fail && fail(); };
      document.head.appendChild(s);
    }catch(e){ fail && fail(e); }
  }

  // If someone already loaded mqtt, keep it.
  if (window.mqtt) return;

  // Try to load the real library from local path.
  loadReal(REAL_PATH, function(){
    // If mqtt is now present, great.
    if (window.mqtt && typeof window.mqtt.connect === 'function') {
      console.log('[mqtt.loader] using mqtt.actual.min.js');
      return;
    }
    // Fallback to stub if the real script didn’t attach mqtt.
    makeStub();
  }, function(){
    // Couldn’t load real script; use stub.
    makeStub();
  });

  // ---- Dev Stub (local pub/sub) -------------------------------------
  function makeStub(){
    console.warn('[mqtt.loader] mqtt.actual.min.js not found. Using DEV STUB (no broker connection).');

    // Small event emitter
    function Evt(){ this._ = {}; }
    Evt.prototype.on = function(k, fn){ (this._[k]=this._[k]||[]).push(fn); };
    Evt.prototype.emit = function(k){ var a=this._[k]||[]; for(var i=0;i<a.length;i++){ try{ a[i].apply(null,[].slice.call(arguments,1)); }catch(e){ console.error(e);} } };

    // Global in-page bus for "topics"
    var bus = new Evt();

    // Client factory (API-like)
    function Client(url, opts){
      this._url = url; this._opts = opts||{};
      this._evt = new Evt();
      this._subs = new Set();
      var self=this;
      // Simulate async connect
      setTimeout(function(){ self._evt.emit('connect'); }, 50);
    }
    Client.prototype.on = function(ev, fn){ this._evt.on(ev, fn); };
    Client.prototype.end = function(){ this._evt.emit('close'); };
    Client.prototype.subscribe = function(topic, opts, cb){
      if (typeof opts === 'function'){ cb = opts; opts = {}; }
      this._subs.add(topic);
      if (cb) try{ cb(null, [{topic:topic, qos:(opts && opts.qos) || 0}]); }catch(_){}
    };
    Client.prototype.unsubscribe = function(topic, cb){
      this._subs.delete(topic);
      if (cb) try{ cb(); }catch(_){}
    };
    Client.prototype.publish = function(topic, payload, opts){
      // loop locally to all clients via the bus
      bus.emit('message', topic, (payload==null?'':String(payload)));
      this._evt.emit('message', topic, (payload==null?'':String(payload)));
    };

    // Relay bus messages to all clients that subscribed
    // (In this stub, we don’t track clients; we deliver to everyone)
    // The app already filters by topic.
    // We still expose client.on('message') above.

    window.mqtt = {
      connect: function(url, opts){
        var c = new Client(url, opts);
        // Bridge bus to client .on('message') for all messages
        bus.on('message', function(topic, payload){
          // If client subscribed to that topic, deliver:
          // (We don’t store per-client subs here; the app uses its own topic map.)
          // To emulate mqtt.js behavior, just deliver; app will match.
          c._evt.emit('message', topic, payload);
        });
        return c;
      }
    };
  }
})();
